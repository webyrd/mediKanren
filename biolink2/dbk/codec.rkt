#lang racket/base
(provide encode decode sizeof nat-type/max)
(require racket/list racket/match)

(define (<< i s) (arithmetic-shift i s))
(define (>> i s) (arithmetic-shift i (- s)))
(define (& a b)  (bitwise-and a b))
(define (\| a b) (bitwise-ior a b))
(define (^ a b)  (bitwise-xor a b))

(match-define (list t.bytes t.string t.symbol t.array t.pair
                    t.true t.false t.null t.number
                    ;; TODO: support more efficient numeric representations
                    t.nat t.neg t.int t.float)
  (range (length '(t.bytes t.string t.symbol t.array t.pair
                   t.true t.false t.null t.number
                   t.nat t.neg t.int t.float))))

(define (nat-type/max max-nat) `#(nat ,(- (sizeof 'nat max-nat) 1)))

(define (sizeof type v)
  (match type
    (#f                    (sizeof-any          v))
    (`#(nat    ,size)      (sizeof-nat    size  v))
    (`#(string ,len)       (sizeof-string len   v))
    (`#(symbol ,len)       (sizeof-symbol len   v))
    (`#(bytes  ,len)       (sizeof-bytes  len   v))
    (`#(array ,len ,t)     (sizeof-array  len t v))
    (`#(list  ,len ,t)     (sizeof-list   len t v))
    (`#(tuple ,@ts)        (sizeof-tuple  ts    v))
    (`(,ta . ,td)          (sizeof-pair   ta td v))
    ('nat                  (sizeof-nat    #f    v))
    ('string               (sizeof-string #f    v))
    ('symbol               (sizeof-symbol #f    v))
    ('bytes                (sizeof-bytes  #f    v))
    ('array                (sizeof-array  #f #f v))
    ('list                 (sizeof-list   #f #f v))
    ('number               (sizeof-number       v))
    ((or 'true 'false '()) 0)))
(define (sizeof-any v)
  (+ 1 (cond ((vector? v) (sizeof-array  #f #f v))
             ((string? v) (sizeof-string #f    v))
             ((bytes?  v) (sizeof-bytes  #f    v))
             ((pair?   v) (sizeof-pair   #f #f v))
             ((number? v) (sizeof-number       v))
             ((symbol? v) (sizeof-symbol #f    v))
             ((or (null? v) (eqv? #t v) (not v)) 0)
             ((void? v)                          #f)
             (else (error "sizeof-any; invalid type:" v)))))
(define (sizeof-nat size n)
  (cond (size      size)
        ((void? n) #f)
        (else (+ 1 (cond ((< n (<< 1 32)) (if (< n (<< 1 16))
                                            (if (< n (<< 1 8))  1 2)
                                            (if (< n (<< 1 24)) 3 4)))
                         ((< n (<< 1 40) 5))
                         ((< n (<< 1 48) 6))
                         ((< n (<< 1 56) 7))
                         ((< n (<< 1 64) 8))
                         (else (error "sizeof-nat; too large:" n)))))))
(define (sizeof-number v)   (sizeof-string #f (if (void? v) v
                                                (number->string v))))
(define (sizeof-bytes l v)  (or l (and (not (void? v))
                                       (let ((len (bytes-length v)))
                                         (+ len (sizeof-nat #f len))))))
(define (sizeof-symbol l v) (or l (sizeof-string l (if (void? v) v
                                                     (symbol->string v)))))
(define (sizeof-string l v) (or l (sizeof-bytes l (if (void? v) v
                                                    (string->bytes/utf-8 v)))))
(define (sizeof-pair ta td v) (let ((za (sizeof ta (if (void? v) v (car v))))
                                    (zd (sizeof td (if (void? v) v (cdr v)))))
                                (and za zd (+ za zd))))
(define (sizeof-tuple ts v) (sizeof ts (if (void? v) v (vector->list v))))
(define (sizeof-list l t v)
  (if l (sizeof-tuple (make-list l t) v)
    (and (not (void? v)) (let* ((l (length v))
                                (z (sizeof-list l t v)))
                           (and z (+ (sizeof-nat #f l) z))))))
(define (sizeof-array l t v)
  (if l (sizeof-tuple (make-list l t) v)
    (and (not (void? v)) (let ((z (sizeof-array (vector-length v) t v)))
                           (and z (+ (sizeof-nat #f (vector-length v)) z))))))

(define (encode out type v)
  (match type
    (#f                    (encode-any    out       v))
    (`#(nat    ,size)      (encode-nat    out size  v))
    (`#(string ,len)       (encode-string out len   v))
    (`#(symbol ,len)       (encode-string out len   (symbol->string v)))
    (`#(bytes  ,len)       (encode-bytes  out len   v))
    (`#(array ,len ,t)     (encode-array  out len t v))
    (`#(list  ,len ,t)     (encode-list   out len t v))
    (`#(tuple ,@ts)        (encode-tuple  out ts    v))
    (`(,ta . ,td)          (encode-pair   out ta td v))
    ('nat                  (encode-nat    out #f    v))
    ('string               (encode-string out #f    v))
    ('symbol               (encode-string out #f    (symbol->string v)))
    ('bytes                (encode-bytes  out #f    v))
    ('array                (encode-array  out #f #f v))
    ('list                 (encode-list   out #f #f v))
    ('number               (encode-number out       v))
    ((or 'true 'false '()) 0)))
(define (encode-any out v)
  (define (tag t) (encode-nat out 1 t))
  (cond ((vector? v) (tag t.array)  (encode-array  out #f #f v))
        ((string? v) (tag t.string) (encode-string out #f    v))
        ((bytes?  v) (tag t.bytes)  (encode-bytes  out #f    v))
        ((pair?   v) (tag t.pair)   (encode-pair   out #f #f v))
        ((number? v) (tag t.number) (encode-number out       v))
        ((symbol? v) (tag t.symbol) (encode-string out #f (symbol->string v)))
        ((null?   v) (tag t.null))
        ((eqv? #t v) (tag t.true))
        ((not     v) (tag t.false))
        (else (error "encode-any; invalid type:" v))))
(define (encode-nat out size n)
  (define (enc/size sz) (unless (= sz 0)
                          (write-byte (& #xFF (>> n (* 8 (- sz 1)))) out)
                          (enc/size (- sz 1))))
  (define (enc sz) (encode-nat out 1 sz) (enc/size sz))
  (cond (size (enc/size size))
        ((< n (<< 1 32)) (if (< n (<< 1 16))
                           (if (< n (<< 1 8))  (enc 1) (enc 2))
                           (if (< n (<< 1 24)) (enc 3) (enc 4))))
        ((< n (<< 1 40) (enc 5)))
        ((< n (<< 1 48) (enc 6)))
        ((< n (<< 1 56) (enc 7)))
        ((< n (<< 1 64) (enc 8)))
        (else (error "encode-nat; too large:" n))))
(define (encode-number out n) (encode-string out #f (number->string n)))
(define (encode-bytes out len bs)
  (unless len (encode-nat out #f (bytes-length bs)))
  (write-bytes bs out))
(define (encode-string out len s)
  (encode-bytes out len (string->bytes/utf-8 s)))
(define (encode-pair   out ta td v)
  (encode out ta (car v)) (encode out td (cdr v)))
(define (encode-tuple out ts v) (for ((t (in-list ts)) (v (in-vector v)))
                                     (encode out t v)))
(define (encode-list out l t v)
  (unless l (encode-nat out #f (length v)))
  (for ((v (in-list v))) (encode out t v)))
(define (encode-array out l t v)
  (unless l (encode-nat out #f (vector-length v)))
  (for ((v (in-vector v))) (encode out t v)))

(define (decode in type)
  (match type
    (#f                              (decode-any    in))
    (`#(nat    ,size)                (decode-nat    in size))
    (`#(string ,len)                 (decode-string in len))
    (`#(symbol ,len) (string->symbol (decode-string in len)))
    (`#(bytes  ,len)                 (decode-bytes  in len))
    (`#(array ,len ,t)               (decode-array  in len t))
    (`#(list  ,len ,t)               (decode-list   in len t))
    (`#(tuple ,@ts)                  (decode-tuple  in ts))
    (`(,ta . ,td)                    (decode-pair   in ta td))
    ('nat                            (decode-nat    in #f))
    ('string                         (decode-string in #f))
    ('symbol         (string->symbol (decode-string in #f)))
    ('bytes                          (decode-bytes  in #f))
    ('array                          (decode-array  in #f #f))
    ('list                           (decode-list   in #f #f))
    ('number                         (decode-number in))
    ('true                           #t)
    ('false                          #f)
    ('()                             '())))
(define (decode-any in)
  (define tag (decode-nat in 1))
  (define (? t) (= tag t))
  (cond ((? t.array)                  (decode-array  in #f #f))
        ((? t.string)                 (decode-string in #f))
        ((? t.bytes)                  (decode-bytes  in #f))
        ((? t.pair)                   (decode-pair   in #f #f))
        ((? t.number)                 (decode-number in))
        ((? t.symbol) (string->symbol (decode-string in #f)))
        ((? t.null)                   '())
        ((? t.true)                   #t)
        ((? t.false)                  #f)
        (else (error "decode-any; invalid tag:" tag))))
(define (decode-nat in size)
  (if size (let loop ((n 0) (sz size))
             (if (= sz 0) n
               (loop (+ (<< n 8) (read-byte in)) (- sz 1))))
    (let ((size (decode-nat in 1))) (decode-nat in size))))
(define (decode-number in)      (string->number (decode-string in #f)))
(define (decode-bytes in l)     (if l (read-bytes l in)
                                  (decode-bytes in (decode-nat in #f))))
(define (decode-string in l)    (bytes->string/utf-8 (decode-bytes in l)))
(define (decode-pair  in ta td) (cons (decode in ta) (decode in td)))
(define (decode-tuple in ts)    (list->vector (decode in ts)))
(define (decode-list  in l t)   (if l (decode in (make-list l t))
                                  (decode-list in (decode-nat in #f) t)))
(define (decode-array in l t)   (if l (decode-tuple in (make-list l t))
                                  (decode-array in (decode-nat in #f) t)))
